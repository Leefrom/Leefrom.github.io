<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[语法、变量以及数据类型]]></title>
    <url>%2F2018%2F03%2F24%2F%E8%AF%AD%E6%B3%95%E3%80%81%E5%8F%98%E9%87%8F%E4%BB%A5%E5%8F%8A%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[###基本概念1.javascript对于大小写敏感 2.标识符（就是变量、函数、属性的名字或者函数的参数），标识符可以是按照下列格式规则组合起来的一或多个字符。 第一个字符必须是一个字母、下划线_或者一个美元符号$ 其他字符可以是字母、下划线、美元符号或者数字。按照惯例，ECMAScript标识符采用驼峰大小写格式（第一个字母小写，剩下单词的首字母大写） ####严格模式3.严格模式use strict 为js定义了一种不同的解析与执行模型，在严格模式下，一些不确定的行为将得到处理，而且对某些不安全的操作也会抛出错误。这串字符是一个编译指示，用于告诉支持js引擎切换到严格模式。 4.保留字与关键字不能作为标识符使用。 变量5.ECMAScript的变量是松散类型的，可以保存任何类型的数据。定义变量的时候要用var操作符，var message;这样定义会保存一个undefined的值，在函数中定义var会将该变量定义成局部变量，在函数退出后就会被销毁掉。12345function test()&#123; var message = "hi"; //局部变量&#125;test();alert(message); //错误 &emsp;&emsp;变量message在函数中使用var定义，函数被调用的时候创建并为其赋值。在此之后，这个变量又会立即被销毁。12345function test()&#123; message = "hi"; //全局变量&#125;test();alert(message); //"hi" 省略var之后message成为了全局变量，只要调用过一次test()函数，这个变量就有了定义，就可以在函数外部任何的地方被访问到。但是不推荐在函数内部定义全局变量，这样很难维护。 由于ECMAScript是松散类型的，可以用一条语句定义多个变量，只需要像下面这样把每个变量用逗号分隔开即可（换行和变量缩进不是必须的，但是这样可提高代码的可读性）：123var message = "hi", found = false, age = 29; 数据类型6.由于ECMAScript是松散类型的，因为需要用typeof来检测给定变量的数据类型，typeof是一个操作符而不是函数，因此type()可以使用但是不是必须的。从技术角度上面讲，函数在ECMAScript中是对象，不是一种数据类型，然而函数也确实有一些特殊的属性，所以通过typeof操作符来区分函数和其他对象是有必要的 ECMAScript中有5种简单的数据类型(基本数据类型)， Undefined //typeof值未定义&nbsp;undefined类型只有一个值，即特殊的undefined，var message;声明变量但未对其初始化的时候，这个变量的值就是undefined。但是包含undefined的值与尚未定义的变量还是不一样的。 123456789var message;alert(message); //"undefined"alert(age); //age未定义，产生错误但是用typeof的结果是不一样的var message;alert(typeof message); //"undefined"alert(typeof age); //"undefined" Null&nbsp;null也是只有一个值的类型，值为null。从逻辑角度看null值表示一个空对象指针，而是为什么使用typeof操作符检测null值时会返回“object”的原因。 12var call = null;alert(typeof car); //"object" &emsp;如果定义的变量在将来用于保存对象，那么最好将该变量初始化为null而不是其他值。这样的话只要直接检查null就可以知道相应的变量是否已经保存了一个对象的引用。如下：12345if (car != null)&#123; // 对car对象进行某些操作&#125;实际上undefined的值是派生自null值的，所以alert(null == undefined); //true &emsp;null==undefined总是返回true。尽管null和undefined有这样关系，但是null和undefined的用途完全不同。我们知道不需要将一个值显示的设置为undefined，但是有必要将一个需要保存对象的变量在还没有保存变量时设置为null。这样不仅可以体现null作为空对象指针的惯例，而且也有助于进一步区分null和undefined。 Boolean // typeof值是布尔值&nbsp;Boolean类型是ECMAScript中使用的最多的一种类型，该类型只有两个字面值：true和false。这两个值和数字值不是一回事，true不一定是1，false也不一定等于0,需要注意的是true和false是区分大小写的，True和False不是Boolean值，只是标识符。&emsp;虽然Boolean类型的字面值只有两个，但ECMAScript中所有类型的值都与这两个Boolean值等价的值。只需要用转型函数Boolean()转换即可。12var message = "hello word";var messageAsBoolean = Boolean(message); //true值 &emsp;转值表如下： 数据类型 转换为true的值 转换为false的值 Undefined N/A undefined Boolean true false String 任何非空字符串 “”(空字符串) Number 任何非零数字值(包括无穷大) 0和NaN Object 任何对象 null &emsp;这些转换规则对理解流控制语句(if语句等)自动执行相应的Boolean转换非常重要。1234var message = "hello world";if (message)&#123; alert("Value is true"); //会alert出来&#125; Number // typeof值是数值&emsp;数值有整数和浮点数值，最基本的数值字面量格式是十进制整数(10)，除了十进制整数之外还可以通过八进制(012)或者16进制(0xA)字面值来表示。[括号里面是10在不同进制下面的的表现形式。八进制第一位必须是0，如果数值超过了八进制的范围，那么前导零会被忽略，后面的数值将被当做十进制数值数值进行解析，且八进制字面量在严格模式下是无效的。十六进制前两位必须是0x，后跟十六进制的数字或字母，可以小写也可以大写。] &emsp;&emsp;浮点数值——由于保存浮点数值需要的内存空间是保存整数值的两倍，因为ECMAScript会不失时机的将浮点数值转换为整数值。在小数点后面没有跟任何数字或者这个浮点数值本身表示的就是一个整数，这些值都会被转换为整数。&emsp;&emsp;对于极大或者极小的数值可以用e来表示，大写小写均可。e.g. 3.125e7=3.125X10^7=31250000；3e-7=3X10^-7=0.0000003。在默认情况下，ECMAScrpit会将那些小数点后面带有6个零以上的浮点数值转换为以e表示法表示的数值。&emsp;&emsp;浮点数值的最高精度是17位小数，但在进行算术计算时其精度远远不如整数，例如0.1+0.2的结果不是0.3,而是0.300000004。所以舍入误差导致无法测试特定的浮点数值。 &emsp;&emsp;数值范围——由于内存限制，ECMAScript并不能保存世界上所有的数值，存在最小数值以及最大数值分别存在Number.MIN_VALUE和Number.MAX_VALUE中。&emsp;如果某次计算得到一个超出JS数值范围的值，那么这个值会自动转换为特殊的Infinity值。如果这个数值是负数会转换为-Infinity，如果这个数值是正数会被转换为Infinity。&emsp;如果返回Infinity值，那么该值无法继续参与下一次的计算。&emsp;想要确定一个数值是不是有穷的，可以使用isFinite()函数，这个函数在参数位于最小与最大数值之间时会返回true。12var result = Number.MIN_VALUE+Number.MAX_VALUE;alert(isFinite(result)); //false 访问Number.NEGETIVE_INFINITY和Number.POSITIVE_INFINITY也可以得到负和正的Infinity值。 &emsp;&emsp;NaN——not a number用于表示一个本来要返回数值的操作数未返回数值的情况（这样就不会抛出错误了），在其他变成语言中任何数值除以非数值都会导致错误，从而停止代码执行。但在ECMAScript中，任何数值除以非数值会返回NaN，因此不会影响其他代码的执行。&emsp;NaN本身有两个特点。&emsp;&emsp;1.首先任何涉及NaN的操作，都会返回NaN。&emsp;&emsp;2.NaN与任何值都不相等，包括NaN本身。alert(NaN == NaN) //false&emsp;针对NaN的这两个特点，ECMAScript定义了isNaN( )函数，这个函数接收一个任何类型的参数，函数会确定这个参数是否不是数值。isNaN()在接收一个值后会尝试将这个值转换为数值，不能转换为数值的值都会导致这个函数返回true。12345alert(isNaN(NaN)); //truealert(isNaN(10)); //false 10是一个数值alert(isNaN("10")); //false 可以被转换为数值10alert(isNaN("blue"));//true 不能转换成数值alert(isNaN(true)); //false 可以被转换为数值1 *isNaN()确实也适用于对象，在基于对象调用isNaN()函数时，会首先调用对象的valueof()方法，然后确定该方法返回的值是否可以转换为数值。如果不能，则基于这个返回值再调用toString()方法，再测试返回值。 &emsp;&emsp;数值转换——Number()、parseInt()、psrseFloat()可以将非数值转换为数值。Number()函数可以用于任何数据类型的转换，而另外两个则专门用于把字符串转换成数值。&emsp;&emsp;Number()转换规则如下：&emsp;&emsp;- Boolean类型，true和false将分别转换为1和0。&emsp;&emsp;- 数字值，简单的传入和返回。&emsp;&emsp;- null值，返回0。&emsp;&emsp;- Undefined，返回NaN。&emsp;&emsp;- 字符串&emsp;&emsp;&emsp;1.字符串中只包含数字（包括带正号或者负号的情况）,则将其转换为十进制数值，”011”会变成11，前导0都会忽略（下方适用）。&emsp;&emsp;&emsp;2.包含有效的浮点格式，e.g.”1.1”则将其转换为对应的浮点数值。&emsp;&emsp;&emsp;3.包含有效的十六进制格式，e.g.”0xf”将其转换为相同大小的十进制整数值。&emsp;&emsp;&emsp;4.如果字符串是空的，则将其转换为0。&emsp;&emsp;&emsp;5.如果包含除上述格式之外的字符，则将其转换为NaN。&emsp;&emsp;- 对象，调用ValueOf()方法，然后依照前面的规则转换返回的值。如果转换的结果是NaN，则调用对象的toString()方法，然后再次依照前面的规则转换返回的字符串。1234var num1 = Number("hello world"); //NaNvar num2 = Number(""); //0var num3 = Number("000011"); //11var num4 = Number(true); //1 &emsp;&emsp;parseInt()。在转换字符串时由于Number()比较复杂而且不够合理，因此在处理整数的时候更常用的是parseInt()函数。parseInt()函数在转换字符串时，更多的是看其是否符合数值模式。&emsp;&emsp;它会忽略字符串前面的空格，直至找到第一个非空格字符。如果第一个字符不是数字字符，parseInt()就会返回NaN,也就是说用parseInt()转换空字符串会返回NaN(Number()对空字符返回0)。如果第一个字符是数字字符,会继续解析第二个字符，直到解析完所有后续字符或者遇到了一个非数字字符，e.g.”1234blue”会被转换成1234，”22.5”会被转换为22，因为小数点并不是有效的数字字符。&emsp;&emsp;为了消除在使用parseInt()函数在八进制和十六进制可能存在的问题，可以为这个函数提供第二个参数：转换时使用的基数。1234var num = parseInt("0xAF",16); //175如果指定了16作为第二个参数，字符串可以不带前面的"0x"，var num1 = parseInt("AF",16); //175var num2 = parseInt("AF"); //NaN,因为没有指定说要解析十六进制的字符串，所以转换发现第一个字符不是数字字符。 &emsp;&emsp;parseFloat()。也是从第一个字符开始解析每个字符，一直解析到字符串末尾，或者解析到遇见一个无效的浮点数字字符为止。字符串中的第一个小数点是有效的，而第二个小数点就是无效的了，因此它后面的字符串将被忽略。除此之外，parseFloat()与parseInt()的第二个区别在于它可以识别前面讨论过的所有浮点数值格式，也包括十进制整数格式。但十六进制的字符串始终会被转换为0。如果字符串包含的是一个可解析为整数的数，会返回整数。 String // typeof值是字符串&nbsp;还有一种复杂的数据类型 Object(由一组无须的名值对组成的) // typeof值是对象或者null // typeof为function,这个值是函数的时候]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>语法</tag>
        <tag>保留字</tag>
        <tag>关键字</tag>
        <tag>变量</tag>
        <tag>数据类型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[script、noscript以及文档模式]]></title>
    <url>%2F2018%2F03%2F20%2Fscript%E3%80%81noscript%E4%BB%A5%E5%8F%8A%E6%96%87%E6%A1%A3%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[&lt;script&gt;&lt;script&gt;下列的几个我经常见的属性： async表示应该立即下载脚本，但不妨碍页面中的其他操作，比如下载其他资源或等待加载其他脚本，只对外部脚本文件有效。[异步]异步脚本一定会再页面的load事件前执行，但可能会在DOMContentLoaded事件触发之前或之后执行。 defer表示脚本可以延迟到文档完全被解析和显示之后再执行。[延迟] 放在head标签里面的时候加上defer属性脚本会立即下载，但延迟执行。 type表示编写代码使用的脚本语言的内容类型（MIME类型），type值默认为text/javascript，但是服务器在传输过程中使用的MIME类型通常是application/x-javascript,type不设置为这个值是因为设置这个值可能导致脚本被忽略。 在使用&lt;script&gt;解析嵌入代码的时候不要在任何地方出现&lt;/script&gt;,会认为是结束的标志，若有需要使用转义字符\来解决这个问题。 &emsp;&emsp;在引入外部js文件的时候是&lt;script type=&quot;text/javascript&quot; src=&quot;xx.js&quot;&gt;，如果在引入外部js文件的同时包含嵌入的代码，嵌入的代码会被忽略只会下载并执行外部脚本文件。引入外部文件浏览器会根据具体的设置来缓存链接的所有外部文件，如果有两个页面都使用同一个文件，那么这个文件只需下载一次，最终结果能够加快页面的加载速度。 &emsp;&emsp;通过src属性还可以包含来自外部域的javascript文件，与img相同，可以指向当前HTML页面所在域之外的某个域中的完整URL。 &emsp;&emsp;无论如何包含代码。只要不存在defer和async属性，浏览器都会按照&lt;script&gt;元素在页面出现的先后顺序对他们依次进行解析。defer会按照前后顺序执行，但标记async的脚本并不保证按照他们的先后顺序执行。 &lt;noscript&gt;&emsp;&emsp;&lt;noscript&gt;是在浏览器不支持js脚本的时候会显示出来。12345&lt;body&gt; &lt;noscript&gt; &lt;p&gt;本页面需要浏览器支持Javascript&lt;/p&gt; &lt;/noscript&gt; &lt;/body&gt; 文档模式&emsp;&emsp;文档模式是通过文档类型Doctype切换来实现的，最初的两种文档模式是混杂模式和标准模式。 &emsp;&emsp;如果在文档的开始处没有发现文档类型声明，则所有的浏览器会默认开启混杂模式，但是不同浏览器咋这种模式下的行为差异非常大。&emsp;&emsp;而标准模式会让浏览器的行为更接近标准行为，准标准模式与标准模式差别不大。]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>script</tag>
        <tag>文档模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javascript=ECMAScript+DOM+BOM]]></title>
    <url>%2F2018%2F03%2F16%2FDOM%2F</url>
    <content type="text"><![CDATA[DOM(Document Object Model)将整个页面映射为一个多层节点结构，借助DOM提供的API可以自如的删除、添加、替换或修改任何节点。 DOM1级主要是映射文档结构。 DOM2级扩充了鼠标和用户界面事件、范围、遍历等细分模块，而且通过对象接口增加了对CSS的支持。DOM2级引入了下列新模块，也给出了众多新类型和新接口的定义。 DOM视图(Views)：跟踪不同文档视图的接口（e.g.应用css之前后和之后的文档） DOM事件(Events)：定义了事件和事件处理的接口 DOM样式(Style)：定义了基于CSS为元素应用样式的接口 DOM遍历和范围(Traversal and Range)：定义了遍历和操作文档树的接口 DOM3引入了以统一方式加载和保存文档的方法(DOM Load and Save)，新增了验证文档的方法(DOM Validation)。 BOM(Browser Object Model)可以控制浏览器显示页面以外的部分,处理浏览器窗口和框架，支持访问和操作浏览器窗口。在HTML5中把很多BOM功能写入了正式规范。人们习惯上也把所有针对浏览器的Javascript扩展算作BOM的一部分。 弹出新浏览器窗口的功能 移动、缩放和关闭浏览器窗口的功能 提供浏览器详细信息的navigator对象 提供浏览器所加载页面的详细信息的location对象 提供用户显示器分辨率详细信息的screen对象 对cookies的支持 像XMLHttpRequest和IE的ActiveXObject这样的自定义对象 Js由以下三个不同的部分组成： ECMAScript提供核心语言功能 DOM文档对象模型提供访问和操作页面内容的方法和接口 BOM浏览器对象模型提供与浏览器交互的方法与接口各浏览器的支持情况在ES上面大致相同，但是在DOM和BOM在共同特性上虽然一致但是还是会有差异。]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>DOM</tag>
        <tag>BOM</tag>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo+github+next主题更换+个人终端更换]]></title>
    <url>%2F2018%2F03%2F15%2Fabout-hexo%2F</url>
    <content type="text"><![CDATA[hexo+github+域名 hexo的部署前期我是看的这篇博客hexo+github搭建个人博客(超详细教程)，博主写的很详细了。总结下来就是： 首先安装git，其次安装node.js 新建hexo文件夹（这就是本地上博客所在的地方），在文件夹内使用git bash安装hexo ,命令npm install -g hexo（npm是随前面node.js一起安装的包管理工具），然后继续在hexo文件夹内部署hexo博客即可 然后按照步骤跟github链接上即可，在一系列部署之后我们每次只需要hexo clean清除一下缓存，之后hexo g -d就把网站部署到了github上。hexo g是将改动的在本地重新生成，hexo d是将生成的文件立即部署到网站 next主题更换hexo安装部署完成之后hexo文件夹内如图 public是每个我们hexo g之后的文件夹，也是我们deploy到github上的文件夹。总而言之是整个博客网站的html、css、js、images的渲染文件。 source是我们博客里面放各种文章以及博客跳转的页面也就是写博客的主要工作目录，e.g.下面这些建立的都在source文件夹里面。hexo new &#39;title&#39;新建文章，hexo new page &#39;page&#39;新建页面。 themes里面放的就是hexo的主题，最开始安装的时候有一个landscape的主题，对，就是你们localhost：4000看到的样子。 hexo有很多各种各样的主题，最终我选择了next，我们在themes文件夹下面直接git clone这个主题就行了，具体clone的链接点击next在github上面的项目然后复制链接即可。 在这里我们需要注意两个文件，hexo文件下的_config,yml文件通常在被称为站点配置文件。themes里面的next主题里面的_config.yml文件被称为主题配置文件。 一般与next主题自己有关的都是在主题配置文件里面设置，更改的布局及样式都是在next这个文件夹内的文件里面进行修改。 我们要做的唯一一件事情就是在站点配置文件下面theme后面改为next，这样就启动了next这个主题（.yml文件要注意空格）。 关于next主题的各项设置网上随便一搜一大把，大家唯一需要注意的是版本号，不同版本存在着一些细微的区别，但是大致相同。 在next里面layout这个文件夹里面的.swig文件是各种不同页面的布局，source文件则是页面的组件的css、image之类的。 祝大家享受搭建自己博客的过程，enjoy~关于博客的一些其他的内容我会在后续的文章里面写到，欢迎大家留言探讨~]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>next</tag>
      </tags>
  </entry>
</search>
